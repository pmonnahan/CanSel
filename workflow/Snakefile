# Load modules
import glob
import os
import subprocess
import pdb


# Get the date
from datetime import datetime
i = datetime.now()
TIME = i.strftime('%Y-%m-%d')

# Specify config file
configfile: "workflow/config.yml"

# Parse config.yml file
VCF = config['vcfs']['1000g']
POPKEY = config['pop_key']
NSTATS = config['nucleotide_stats']
HSTATS = config['haplotype_stats']
REFPOP = config['reference_pop']
QUERY = config['query_pops']
CHROMS = VCF.keys()
VENV = config['python_virtual_env']
WSIZE = config['window_size']
GMAP = config['genetic_map']

if QUERY == 'all':
    POPS = []
    with open(POPKEY, 'r') as pop_file:
        for i, line in enumerate(pop_file):
            pop = line.strip().split("\t")[3]
            if i != 0 and pop != '':
                POPS.append(pop)
    POPS = list(set(POPS))
else:
    POPS = QUERY.split(",")

# Make subdirectories
if not os.path.exists("data"):
    os.mkdir("data")
if not os.path.exists("nucleotide_stats"):
    os.mkdir("nucleotide_stats")
if not os.path.exists("haplotype_stats"):
    os.mkdir("haplotype_stats")
if not os.path.exists("accessory"):
    os.mkdir("accessory")
if not os.path.exists("OandE"):
    os.mkdir("OandE")

localrules: all, concatenate_results, clean

CONDA = f'source /panfs/roc/msisoft/anaconda/anaconda3-2018.12/bin/activate; conda activate {VENV}; export PATH=$PATH:/panfs/roc/msisoft/anaconda/anaconda3-2018.12/bin/'

rule all:
    input:
        expand(f"data/ZarrFile/{{chrom}}/calldata/GT/0.0.0", chrom=CHROMS),
        expand(f"nucleotide_stats/{{pop}}.chr{{chrom}}.nwn.{{metric1}}.csv", pop=POPS, chrom=CHROMS, metric1=NSTATS['within_pop'].split(",")),
        expand(f"nucleotide_stats/{{pop}}.chr{{chrom}}.nbn.{{metric2}}.csv", pop=POPS, chrom=CHROMS, metric2=NSTATS['between_pop'].split(",")),
        expand(f"haplotype_stats/{{pop}}.chr{{chrom}}.hwn.{{metric3}}.csv", pop=POPS, chrom=CHROMS, metric3=HSTATS['within_pop'].split(",")),
        expand(f"haplotype_stats/{{pop}}.chr{{chrom}}.hbn.{{metric4}}.csv", pop=POPS, chrom=CHROMS, metric4=HSTATS['between_pop'].split(",")),
        expand(f"accessory/polarization_key.chr{{chrom}}", chrom=CHROMS),
        "AllPops.NucStats.csv.gz", "AllPops.HapStats.csv.gz"

rule clean:
    shell:
        "rm data/*; rm nucleotide_stats/*; rm haplotype_stats/*; rm accessory/*; rm OandE/*"

rule remove_indels:
    input: vcf=lambda wildcards: VCF[wildcards.chrom]
    output: "data/chrom{chrom}.vcf.gz"
    shell:
        f"module load bcftools; bcftools view --types snps {{input.vcf}} | bcftools norm -d -Oz -o data/chrom{{wildcards.chrom}}.vcf.gz"

rule convert_vcf_to_zarr:
    input: "data/chrom{chrom}.vcf.gz"
    output: "data/ZarrFile/{chrom}/calldata/GT/0.0.0"
    shell: f"{CONDA}; python scripts/convert_vcf.py -vcf {{input}} -name {{wildcards.chrom}} -o data/ZarrFile"

#TODO: add SNP numbers for nstat windows
rule calculate_within_population_nucleotide_stats:
    input: "data/ZarrFile/{chrom}/calldata/GT/0.0.0"
    output: f"nucleotide_stats/{{pop}}.chr{{chrom}}.nwn.{{metric1}}.csv"
    shell: f"{CONDA}; python scripts/NucStats.py -z data/ZarrFile -p {{wildcards.pop}} -p2 None -k {POPKEY} -c {{wildcards.chrom}} -s {{wildcards.metric1}} -w {WSIZE} -o {{output}}"

rule calculate_between_population_nucleotide_stats:
    input: "data/ZarrFile/{chrom}/calldata/GT/0.0.0"
    output: f"nucleotide_stats/{{pop}}.chr{{chrom}}.nbn.{{metric2}}.csv"
    shell: f"{CONDA}; python scripts/NucStats.py -z data/ZarrFile -p {{wildcards.pop}} -p2 {REFPOP} -k {POPKEY} -c {{wildcards.chrom}} -s {{wildcards.metric2}} -w {WSIZE} -o {{output}}"

rule make_polarization_key:
    input: "data/ZarrFile/{chrom}/calldata/GT/0.0.0"
    output: f"accessory/polarization_key.chr{{chrom}}"
    shell: f"{CONDA}; python scripts/polarization_key.py -i data/ZarrFile -o accessory/polarization_key.chr{{wildcards.chrom}} -c {{wildcards.chrom}}"

rule calculate_within_population_haplotype_stats:
    input: "data/ZarrFile/{chrom}/calldata/GT/0.0.0",
           f"accessory/polarization_key.chr{{chrom}}"
    output: f"haplotype_stats/{{pop}}.chr{{chrom}}.hwn.{{metric3}}.csv"
    shell: f"{CONDA}; python scripts/HapStats.py -z data/ZarrFile -p {{wildcards.pop}} -p2 None -k {POPKEY} -c {{wildcards.chrom}} -s {{wildcards.metric3}} -o {{output}} -P {{input[1]}} -m {GMAP} --standardize"

rule calculate_between_population_haplotype_stats:
    input: "data/ZarrFile/{chrom}/calldata/GT/0.0.0",
           f"accessory/polarization_key.chr{{chrom}}"
    output: f"haplotype_stats/{{pop}}.chr{{chrom}}.hbn.{{metric4}}.csv"
    shell: f"{CONDA}; python scripts/HapStats.py -z data/ZarrFile -p {{wildcards.pop}} -p2 {REFPOP} -k {POPKEY} -c {{wildcards.chrom}} -s {{wildcards.metric4}} -o {{output}} -P {{input[1]}} -m {GMAP} --standardize"

rule concatenate_results:
    input:
        expand(f"nucleotide_stats/{{pop}}.chr{{chrom}}.nwn.{{metric1}}.csv", pop=POPS, chrom=CHROMS, metric1=NSTATS['within_pop'].split(",")),
        expand(f"nucleotide_stats/{{pop}}.chr{{chrom}}.nbn.{{metric2}}.csv", pop=POPS, chrom=CHROMS, metric2=NSTATS['between_pop'].split(",")),
        expand(f"haplotype_stats/{{pop}}.chr{{chrom}}.hwn.{{metric3}}.csv", pop=POPS, chrom=CHROMS, metric3=HSTATS['within_pop'].split(",")),
        expand(f"haplotype_stats/{{pop}}.chr{{chrom}}.hbn.{{metric4}}.csv", pop=POPS, chrom=CHROMS, metric4=HSTATS['between_pop'].split(",")),
    output: "AllPops.NucStats.csv.gz", "AllPops.HapStats.csv.gz"
    run:
        shell("for f in nucleotide_stats/*nwn*.csv; do head -n 1 $f > header.csv; done")
        shell("for f in haplotype_stats/*hwn*.csv; do head -n 1 $f > header2.csv; done")
        shell("for f in nucleotide_stats/*csv; do tail -n +2 $f >> tmp.csv; done")
        shell("for f in haplotype_stats/*csv; do tail -n +2 $f >> tmp2.csv; done")
        shell("cat header.csv tmp.csv | gzip > AllPops.NucStats.csv.gz")
        shell("cat header2.csv tmp2.csv | gzip > AllPops.HapStats.csv.gz")
        shell("for f in {{1..22}}; do tail -n +2 nucleotide_stats/*chr${{f}}.*csv | grep -v nucleotide >> tmp${{f}}.nuc.csv; done")
        shell("for f in {{1..22}}; do tail -n +2 haplotype_stats/*chr${{f}}.*csv | grep -v haplotype >> tmp${{f}}.hap.csv; done")
        shell("for f in {{1..22}}; do cat header.csv tmp${{f}}.nuc.csv | gzip  > AllPops.chr${{f}}.nuc.csv.gz; done; rm header.csv; rm tmp*.nuc.csv")
        shell("for f in {{1..22}}; do cat header2.csv tmp${{f}}.hap.csv | gzip > AllPops.chr${{f}}.hap.csv.gz; done; rm header2.csv; rm tmp*.hap.csv")

# rule make_db:
#     input:
#         expand(f"nucleotide_stats/{{pop}}.chr{{chrom}}.nwn.{{metric1}}.csv", pop=POPS, chrom=CHROMS, metric1=NSTATS['within_pop'].split(",")),
#         expand(f"nucleotide_stats/{{pop}}.chr{{chrom}}.nbn.{{metric2}}.csv", pop=POPS, chrom=CHROMS, metric2=NSTATS['between_pop'].split(",")),
#         expand(f"haplotype_stats/{{pop}}.chr{{chrom}}.hwn.{{metric3}}.csv", pop=POPS, chrom=CHROMS, metric3=HSTATS['within_pop'].split(",")),
#         expand(f"haplotype_stats/{{pop}}.chr{{chrom}}.hbn.{{metric4}}.csv", pop=POPS, chrom=CHROMS, metric4=HSTATS['between_pop'].split(",")),
#     output: "cansel.db"
#     run:
#         for file in input:
#             if "nucleotide" in file:

# rule simulate_nulls:
# #     input:

rule extract_singletons:
    input: "data/ZarrFile/{chrom}/calldata/GT/0.0.0"
    output: f"haplotype_stats/{{pop}}.chr{{chrom}}.SDS.csv"
    shell: ''

#g = allel.GenotypeChunkedArray(callset[chrom]['calldata']['genotype'])
## the '[:]' syntax pulls the data from compressed storage into a numpy array
#ac = g.count_alleles()[:] #differs for zarr array
#Count singletons
#np.count_nonzero((ac.max_allele() == 1) & ac.is_singleton(1))
#flt = ac.is_singleton(1)
#gf = g.compress(flt, axis=0)